---
title: C++的基本语法
date: 2024-04-01 00:00:00 +0800
last_modified_at: 2024-04-03 00:00:00 +0800
categories: [c, basic]
tags: [c]
author: author1
---
###基础

C++部分语法和C还是很像的，例如循环、判断、指针等。不过C++是面向对象的，封装、继承、多态都包含。

有些常用的与C不一样，如输出`cout << "x"`，也许初看这个会有难记的感觉，实际上，`<<`可以理解成`print`，
即`cout.print("x")`，如`cout << "hello: " << 'paidax'`，即`cout.print("hello: ").print("paidax")`，
结尾的`endl`也是如此，意思是换行至输出流。

#### gcc、g++编译c++

gcc也是可以编译c++代码的，只是链接过程不能自动链接c++的库，因此可以有两种方式（设有一个汇编后的`test.o`）：

```
gcc test.cpp -o test2 -lstdc++
// or
gcc test.o -o test -lstdc++
// or
g++ test.o -o test
```

第一、二个都是一个意思，即使用`-l`参数加上c++库，第二个是链接过程用g++命令进行。

#### 变量

C++提供了基本的数据类型，布尔型`bool`，字符型`char`，整型`int`，浮点型`float`，双浮点型`double`，无类型`void`，宽字符型`wchar_t`，同样的也能用`signed`，`unsigned`，`short`，`long`。其中`wchar_t`是
`typedef short int wchar_t;`。

数据类型重要的吗，其实不重要，不同的数据类型只是区别分配的内存大小，告诉编译器怎么区解释地址这个值
例如设置`type var = 65`，如果`type`是`char`编译器当成`A`，
如果`type`是`int`，编译器当成`65`而已。

`numeric_limits`是一个模板类，它提供了有关各种数值类型的特性信息，如最大值、最小值、精度等。

C++也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等。

`type variable_name = value;`声明定义并初始化，同样的，`extern`关键字也可使用。

同样的，C++中当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化相应值。

类作用域指的是在类内部声明的变量。

#### 函数

同C：
```
return_type function_name( parameter list )
{
   body of the function
}
// 函数声明
return_type function_name( parameter list );
```

当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值，如`int max(int a, int b = 10);`

C++11提供了对匿名函数的支持,称为Lambda函数(也叫Lambda表达式)。 

#### 头文件

头文件其实要和`include`来说，设`main`中需要调用的一个函数，那需要在`main`之前声明这个函数，
告知编译器有这个函数，`include`头文件也一样，`include`在预处理的时候将内容复制一份到你的文件中，
那么在`main`中使用到的`include`文件中的内容不就被声明了吗？就是这样。

一般来说`<>`包含编译器路径，`""`包含很多，例如自己写的用`""`包裹，
这是因为自己写的一般在当前文件夹下，`""`会搜索当前路径例如`"/your_path/xxx"`，
`"iostream"`也是可以的，`""`可以包含路径。

`#pragma once`可以告诉编译器预处理时请只复制一份这个头文件，毕竟如果有变量，
那预处理又是复制粘贴，有些变量就会被定义多次实现只复制一次也不仅这个方法，还有预处理`#ifndef`等。

C++标准库一般没`h`结尾，C有，不要疑惑，这只是C++的开发者想区分一下两者的标准库罢了。

#### 指针

同C一样，C++指针也通过`*`，`&`进行取值、取地址操作。

一样的，`void* a = NULL;`定义了一个`NULL`指针。

`NULL`指针还可以用来做`if`判断，因为`0`是假，计算机不知道什么是假内存中各bit为`0`是假，
而`NULL`指针正好是`0`，所以如果想知道这个指针是不是`NULL`指针，`if`它就好了。

事实上，vs这些IDE或者命令行可以反汇编二进制文件，查看`if`那语句的反汇编代码会发现，
如果条件不成立，会置`0`到地址中去。

#### 引用

引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

与指针不同的是：
- 不存在空引用。引用必须连接到一块合法的内存。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。

创建引用后可以通过原始变量或引用来操作变量，引用符号为`&`。通过引用，我们可以方便地对变量进行别名操作，提高代码的可读性和简洁性。引用不存在空引用，在初始化后不能改变指向，提供了更高的安全性。当然，编码安全更好。

```
// 声明简单的变量
int    i;
double d;
// 声明引用变量
int&    r = i;
double& s = d;
i = 5;
cout << "Value of i : " << i << endl;
cout << "Value of i reference : " << r  << endl;
d = 11.7;
cout << "Value of d : " << d << endl;
cout << "Value of d reference : " << s  << endl;
// output: 
// Value of i : 5
// Value of i reference : 5
// Value of d : 11.7
// Value of d reference : 11.7
```

引用可以用作参数或返回值。

引用只是指针的拓展，真正要理解的是指针，或者说它是指针的语法糖，引用即字面意思，
它是一个引用，没有实际的存储，就像它只需要`type& ref = var`，`var`前面不需要用什么`&`这样的字符，再如下面代码：
```
void addself(int a) {
    a++;
}
// 实际上调用这个函数传入参数，a不会自增，这也是很好理解的，int a实际上是复制了一份
// 真正复制了一份，和传入的叫什么没关系，如果要实现自增，那就传地址，也可以传一个引用
void addself(int* a) {
    (*a)++;
}
// 形参是地址，显然调用需要传入地址，如addself(&var)
// 注意这里*a要加括号，不然就是对地址自增了
void addself(int& a) {
    a++;
}
// 调用这个也可以实现自增，这就是引用，如addself(var)
// 这里var前面不需要加什么&这种奇怪的字符，引用不创建存储地址，只是一个引用罢了
// 语法相比较指针简洁了很多，这就是引用
```

### 面向对象

#### 类

类是C++的核心特性，通常被称为用户定义的类型。

类用于指定对象的形式，是一种用户自定义的数据类型，它是一种封装了数据和函数的组合。类中的数据称为成员变量，函数称为成员函数。类可以被看作是一种模板，可以用来创建具有相同属性和行为的多个对象。

```
class class_name{
	Access specificers://访问修饰符 private, protected, public
		var;
		func;
};
```

如：
```
class Box
{
   public:
      double length;   // 盒子的长度
      double breadth;  // 盒子的宽度
      double height;   // 盒子的高度
	  double get(void); // 可以在类中声明函数
      void set( double len, double bre, double hei );
};
//在外部定义成员函数
double Box::get(void)
{
    return length * breadth * height;
}
// 实例
Box Box1;          // 声明 Box1，类型为 Box
Box Box2;          // 声明 Box2，类型为 Box
```

类的对象的公共数据成员可以使用直接成员访问运算符`.`来访问。
```
Box1.height = 5.0;
Box1.get();
```

类的数据成员和函数成员都可以被声明为静态`static`的。
这里再提一下`static`，这意味着只能在此文件被访问，要知道，全局变量是这个程序中各个文件都可以用的，`static`将变量的空间分配到静态区，只有当源程序结束时才会被释放，而操作系统将局部变量分配在栈区，函数调用结束后就会回收。

**类的构造函数**

类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。

构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回`void`。构造函数可用于为某些成员变量设置初始值。

如：
```
class Line
{
   public:
      void setLength( double len );
      double getLength( void );
      Line();  // 这是构造函数
 
   private: 
      double length;
};
 
// 成员函数定义，包括构造函数
Line::Line(void)
{
    cout << "Object is being created" << endl;
}
```

构造函数也可带参数。

**析构函数**

同样的，类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。

析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

```
...
	~Line();
...
Line::~Line(void)
{
    cout << "Object is being deleted" << endl;
}
```

#### 继承

继承代表了`is a`关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。

语法：
```
class derived-class: access-specifier base-class
```

其中，访问修饰符`access-specifier`是`public`、`protected`或`private`其中的一个，`base-class`是之前定义过的某个类的名称。如果未使用访问修饰符`access-specifier`，则默认为`private`，如：
```
// 基类
class Shape 
{
   public:
      void setWidth(int w)
      {
         width = w;
      }
      void setHeight(int h)
      {
         height = h;
      }
   protected:
      int width;
      int height;
};
// 派生类
class Rectangle: public Shape
{
   public:
      int getArea()
      { 
         return (width * height); 
      }
};
```

派生类可以访问基类中所有的非私有成员（`public`，`protected`）。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为`private`。

一个派生类继承了所有的基类方法，但下列情况**除外**：
- 基类的构造函数、析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

**多继承**
```
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};
// 如上述加上基类 PaintCost
class PaintCost 
{
   public:
      int getCost(int area)
      {
         return area * 70;
      }
};
// 派生类
class Rectangle: public Shape, public PaintCost
{
   public:
      int getArea()
      { 
         return (width * height); 
      }
};
```

#### 重载运算符和重载函数




#### 多态


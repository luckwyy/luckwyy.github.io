---
title: 分解helloworld：头文件、预处理
date: 2024-04-08 00:00:00 +0800
last_modified_at: 2024-04-08 00:00:00 +0800
categories: [cpp, syntax]
tags: [cpp]
author: author1
---

### 目录

#### 前言

C++基本语法一篇markdown每个知识点都记录太长，也难以查看，将不同部分分开，每个点详细更新一篇会好一点。
关于内容：C++的语法和概念很多，想每个概念语法稍微深入一点，一般视频教程也要2、30个小时。
关于更新顺序：更新顺序并不和部分网站从变量等开始相同，想了解cpp的多少都了解点c，因此。

本篇本想从命名空间开始详细更新，但发觉分解helloworld.cpp会更有意思，一段简单的输出helloworld代码反而是很多
新手朋友容易忽略的地方，其实其中的命名空间、预处理`#`符等都值得更深入一点，这对理解一段cpp代码
是如何被编译、执行的会更透彻。

```
// hello.cpp
#include <iostream>
// using namespace std;
int main() {
	std::cout << "Hello World" << std::endl;
	return 0;
}
```

### 正文

#### 头文件和预处理1：预处理意义

写代码是在组织一段文本交给编译器，让编译器看得懂，为了组织好代码，比如相同的部分想拿出来公用，那么不可能将所有的东西都放在一个文件中，将不同功能等代码分解成各个模块存在文件中，需要的时候引用即可，头文件也是这样，当然也不仅仅这么简单。

helloworld中用到了`cout`，实际上如若不引用`#include <iostream>`，`cout`在代码中不存在或者说未声明，因此要在开头将
`iostream`引用，`#`符是预处理符号，还记得编译代码的四个过程吗，预处理、编译、汇编、链接，在预处理过程
引用头文件的作用便出来了，`#include`会把`iostream`的代码复制一份到hello.cpp的开头位置。

但也可以想到，这其中可能存在问题，无法保证变量名、函数名等不会重复，当然解决方法也简单，比如`iostream`中的命名
都用`iostream_xxx`下划线xxx组织起来，但显然这也不是特别好的方法，因此要引出下方命名空间规则。

#### 命名空间

在一些输出helloworld例子中，开头有`using namespace std`，
这就是引入了一个叫`std`的命名空间，如果编写了这一行代码，在后续的调用`cout`中就不需要`std::cout`了，
即告诉了编译器接下来的`cout`在`std`这个空间中，实际上，查看iostream的源码会发现：
```
namespace std _GLIBCXX_VISIBILITY(default)
{
...
```

C++的源码将变量、函数等放到了一个叫`std`的命名空间中（其他文件也是如此）。

还记得gcc有一些参数可以仅做预处理、编译等四个过程吧，
假设在注释`// using namespace std;`的情况下只写`cout`显然会报错，试一试：
```
...
// using namespace std;
...
cout << "Hello World";
```

首先用`gcc -E test.cpp -o test.i`生成预处理文件
（注意`.i`结尾，**gcc --help中说的很清楚，会根据文件名后缀名决定编译器要做什么**），
这一步是不会报错的，因为预处理仅仅复制了一份代码，那接下来编译`gcc -S test.i -o test.s`，
这一步就会报错了：
```
...
error: ‘cout’ undeclared (first use in this function)
...
```

对编译器来说，`cout`是未声明的，因为它在不用`std::cout`显式的告诉编译器`cout`在哪的情况下，
它在预处理后的文件中找不到哪个地方声明了`cout`。

然后是一些语法，`using`不一定非要写在开头，写在需要调用的地方也可以，
也不一定非要`using`整个命名空间，`using std::cout`仅需使用的函数也是可以的。

编程方面，其实不推荐`using`命名空间，需要什么用`::`符号引出更易读。

值得注意的是：C中就没有命名空间的概念，因此C的一些库就是上文提到的规则，其中变量用库名下划线某某命名。

#### 头文件和预处理2：如何防止重复引入

每个知识点都并不是单独存在的，因此描述完命名空间，可以继续说下头文件。

还是以`cout`为例，或者说，引入一些东西是想告诉编译器我声明了（不一定要定义即实现，定义只能定义一次），
请不要报错，这个东西你会在其他地方找到的。

**问题**：`include`是复制粘贴文件，那如果不小心在一个问题中`include`一个头文件多次怎么办？预处理后岂不是有多个相同命名的变量或函数了。

在使用vs新建头文件会发现IDE给头文件加上了`#pragma once`指令，这这个指令在预处理中的意思便是说：
请不要把重复的头文件复制多次，但并不意味着你不能在不同的文件中引入相同的头文件，只是说在同一个文件中
如果引入多个相同的头文件预处理不会复制多次。

创建一个log.h：
```
#pragma once

void log();

void log() {
	std::cout << "log" << std::endl;
}
```

main.h中这样写：
```
#include <iostream>
#include "log.h"
#include "log.h"

int main()
{
	return 0;
}
```

此时，IDE不会报错，因为log.h已经加上了上述指令，如果把`log`函数的定义放在main.h中，此时不用引入log.h也没关系，因为`log`函数在main.h中已经声明并且定义了，这仅仅是想做个例子而已。

如果不加`#pragma once`会怎么样？IDE会报错，告诉你这个函数已经有一个主体了，原因也很简单，因为被复制了两次，
函数可以被声明多次，但是定义只能在一个地方定义。

对于重复问题，解决方法当然也不仅`pragma`声明，预处理指令有很多，而且这个也比较新，不过现在编译器基本都支持`pragma`
这条指令，还可以利用一些预处理指令，例如if not define的缩写`ifndef`，以及配套的`endif`，搭配`define`指令，
`ifndef`的意思就是说如果未定义就怎样，显然可以构造一个变量，顺序是如果未定义它，那就定义它，然后结束，如：
```
//#pragma once
#ifndef ONE
#define ONE

void logger();

void logger() {
	std::cout << "log" << std::endl;
}
#endif // !ONE
```

此时编译main.h也不会报错，哪怕log.h被引入多次。

相反的，`ifdef`指令便是if define的缩写。显然`pragma`要简洁很多。

#### 头文件和预处理3：""和<>引入 以及 一些预处理指令、预处理宏

引入头文件会发现有`""`符号和`<>`号，实际上，一般双引号可以包含一个路径，这意味着你可以在双引号中写：
`"/root/yourlib/yourhead.h"`，尖括号会去设置的路径下搜索，比如linux下`/usr/include`等。

至于为什么`iostream`没有`.h`后缀名，这在C++基本语法的大md中已经说过了，这只是c++库的一种命名，
通常c的拓展库带`.h`后缀名罢了。

对于预处理指令，了解为什么要用印象显然是更加深刻的，
比如上面就学习了`pragma`，`ifndef`，`endif`等用法，预处理指令也不仅仅包括这些，还有很多，例如`#else`和`if`联用，`#line`重新定义行号文件名等，除此之外，预处理指令的参数也是有不同的。

也可以联想到，既然有`define`宏定义，那cpp本身有没有定义一些基本的宏呢？也是有的，比如：
```
std::cout << __LINE__ << std::endl;
```

`__LINE__`便是一个已定义过的宏，意思是当前行号。除此之外还有，`__FILE__`文件名，日期时间`__DATE__`、`__TIME__`等。

指令和宏很多，这些东西要在使用中才会不断了解印象才会深刻。
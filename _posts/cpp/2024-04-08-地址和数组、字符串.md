---
title: 地址和数组、字符串
date: 2024-04-08 00:00:00 +0800
last_modified_at: 2024-04-10 00:00:00 +0800
categories: [cpp, syntax]
tags: [cpp]
author: author1
---

### 前言

C++的数组和字符串要联合内存讲解，毕竟cpp中实际存储的是在地址上存了点数据，因此数组和指针不能分开而说。
本篇可能涉及到：

- 指针的基本知识在C++基本语法中有比较详细说明：`*&`符号分别是取值和取地址符，
`int* _name_`只是告诉编译器要申请一个指针并且是`int`型，不要在意这里的`*`，这和取值符没关系，
既然是申请一个地址，那为什么要告诉编译器类型，取数组值的时候就知道了。
- 了解vs的断点、DEUBG用法、如何打开内存视图，这在C++基本语法中也有介绍。
- 改变数据类型方法：`(int)变量名`

### 正文

#### 数组

数组本质上是一组数据的集合，毕竟不是什么时候都需要一个一个的声明变量，语法：
```
int arr[5];
for (int i = 0; i < 5; i++)
{
    arr[i] = i * 2;
    std::cout << arr[i] << std::endl;
}
std::cout << arr << std::endl;
```

声明数组的语法是`数据类型 变量名[大小]`，在这个例子中，变量名是`arr`，大小是`5`，接着循环访问每个元素，
并且相应下标位置的元素值是下标值×2，问题来了，for循环中`i<5`可以改成`i<6`吗？

是可以的，vs的release模式下运行不会报错，因为数组的本质是在内存地址上存东西，`int arr[5]`中意思是告诉编译器，
请分配连续5个每个占4个字节（int类型4个字节，也可能两个，这个视系统、编译器而定）的空间。因此`arr[5]`确实越界了，但对内存来说可不知道啊，只是在连续的5个地址的接下来一个地址存东西罢了。

好，现在进入断点BEBUG模式，在vs中，将`int arr[5]`打上断点，并且打开vs的内存视图，输入`arr`回车，
可以查看此时地址上值的情况：
```
+		arr	0x00000014c375f6b8 {0xcccccccc, 0xcccccccc, 0xcccccccc, 0xcccccccc, 0xcccccccc}	int[0x00000005]

```

会发现，内存上连续分配了5个4字节的空间，并且每个字节上十六进制是`cc`，这是编译器预先填充的值，继续逐过程运行发现：
```
0x00000014C375F6B8  00 00 00 00 cc cc cc cc cc cc cc cc cc cc cc cc cc c...
0x00000014C375F6B8  00 00 00 00 02 00 00 00 cc cc cc cc cc cc cc cc cc c...
...
```

依次排列下去的地址上写入了相应的值，这也是前面说的为什么`i<6`不会报错，因为本质上是在地址上存东西，
但并不推荐这样做，**在越界的地址上存东西，可能不经意间改变了程序中其他变量的值。**

#### arr代表数组的地址是什么意思，哪个地址？

`std::cout << arr << std::endl;`这行语句会打印出地址，即`arr`变量名本身会打印出数组的地址，
这个数组地址是什么呢？其实**是数组第一个元素第一个字节的地址**，那为什么`*arr`会打印出第一个元素连续4个字节的值呢？`int`不是4个字节吗？可是这个地址仅仅只是第一个字节的地址，这就是为什么要告诉编译器类型了，**正是因为写明了类型，编译器才知道，原来`*arr`要打印连续4个字节的值**。

可以试试：
```
std::cout << arr[i] << std::endl;
std::cout << *(arr+i) << std::endl;
```

首先注意取值符`*`后面用括号括起来了。这两行效果是一样的，arr是第一个元素的第一个字节的地址，那`+i`一个字节的地址`+1`不是相邻的字节吗？这跟上面的原因是一样的，因为告诉了编译器类型，所以编译器知道，
**在`arr`这个地址上`+1`并不是要`arr`相邻字节的地址，而是要连续4个字节后的那个字节的地址**，就是这个意思。

#### 自己计算偏移量给数组元素赋值

**总结来说，地址上+-的偏移量是需要告诉编译器类型的。**，所以可以写出下面这个奇怪的代码：
```
int arr[5];
int* p = arr;
// *(p+3) = 3;
*(int*)((char*)p + 3 * 4) = 3;
std::cout << arr[3] << std::endl;
```

首先`*(p+3)`前面已经说了，第一个`arr`被赋值给了`p`，所以p是第一个元素地址，`p+3`是第四个元素地址。

下面的`*(int*)((char*)p + 3 * 4) = 3;`呢？首先这是能正常运行的，前面说了得告诉编译器类型，所以这里分解成看是：
```
(char*)p
(char*)p + 3 * 4
(int*)((char*)p + 3 * 4)
*...
```

首先将int型的`p`转成char，这里注意，char是1个字节，所以此时这个`p`就是刚刚说的第一个字节的地址了，
那可以想到，此时偏移量得自己计算了，加上连续3个4字节的空间，也就是说此时`p`代表了第13个字节的地址，
因为我们要赋值int类型，所以又把这个地址转成`int *`型，也就是说接下来的`*...`赋值操作是赋了第13个字节后
连续4个字节的值，查看内存会发现：
```
0x00000097331AF9D8  cc cc cc cc cc cc cc cc cc cc cc cc 03 00 00 00 cc cc cc cc
```

这没问题，有趣的是，如果把上面的4改成3呢，即`(char*)p + 3 * 3`,那显然了，在第10个字节地址上接下来的
连续4个字节赋值，查看内存会发现：
```
0x00000007BA1AFB58  cc cc cc cc cc cc cc cc cc 03 00 00 00 cc cc cc cc c...
```

可以印证猜想，确实是这样，告诉编译器类型很重要。

#### new创建数组以及释放内存问题

```
int arr[5];
int* p = new int[5];
delete[] p;
```

上述第二种用`new`关键字创建数组也是可以的，这和第一行不同的是一个在栈上，一个在堆中，栈的跳出作用域会被销毁，堆的生命周期作用在整个程序运行期间，因此需要第三行手动删除分配的内存空间。

这里还值得注意的是：`new`涉及到间接寻址，这意味着`p`实际上的值是一个数组地址，所以可想到这样的内存跳跃会影响性能，在栈上创建数组更有效率。

当然，array、vector一些库也可以创建数组。

这其中还有一个问题，`new`释放内存的时候如何知道该释放连续多少字节的内存，实际上编译器是不知道的，

例如：
```
std::cout << sizeof(arr) << std::endl;
std::cout << sizeof(p) << std::endl;
```

输出分别是`20, 8`，`p`是`8`也很好理解，1个字节8bit，一共64bit，64位地址，
这意味着无法通过`sizeof(arr) / sizeof(int)`知道有多少个数据该释放多少内存，所以维护数组的大小是很重要的，
当然通过array等库有直接的`size()`函数可以知道大小，这也是前面说的间接寻址会影响性能。

#### 字符串和结束标志

字符串也就是一些字符的集合，那问题来了，char型只有一个字节8个比特，怎么只能存256种字符，这怎么存中文其他字符呢？这也是值得了解编译器是如何运作的地方。
```
char str[] = "hello";
char* p = str;
std::cout << p << std::endl;
```

了解了上述数组的知识点，存储字符串一样的，首先编译器自动分配了空间存`str`，查看`p`的内存会发现：
```
0x00000046372FF574  68 65 6c 6c 6f 00 cc cc c...
```

其中`68`等就是hello每个字母对应的ASCII编码，注意后面的`00`，这是特意加上去的，因为编译器没有那么聪明知道字符串
的结尾在哪，`std::cout`能正确打出是因为它遇上了`00`，这是结束的标志，所以这个字符串的长度应该说是`6`，也很好验证，
将代码修改一下：
```
char str[5] = { 'h', 'e', 'l', 'l', 'o'};
//char* p = str;
std::cout << str << std::endl;
```

我们分配了5个空间分别存了对应的字母，没有分配结尾的`00`，断点查看内存会发现：
```
0x00000021406FFD04  68 65 6c 6c 6f cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc e0 0d fe 53 ab 01 00 0...
```

`6f`后面没有跟着`00`，那cout会输出什么呢？答案是会一直输出直到`00`结束，所以要手动加上结尾标志：
```
char str[6] = { 'h', 'e', 'l', 'l', 'o', '\0'};
//char* p = str;
std::cout << str << std::endl;
// 此时str内存：
// 0x00000008326FFA44  68 65 6c 6c 6f 00 cc c...
```

#### string类和<<重载

string类是c++提供的字符串库：
```
#include <iostream>
#include <string>

int main()
{
	std::string str = "hello";
	std::cout << str.size() << std::endl;
	std::cout << str << std::endl;
	return 0;
}
```

这里值得注意的是：`<<`在string库中被重载了，所以能输出string流到终端，在C++基本语法长文中也提到过函数重载和
运算符重载。

string类也提供了很多有用的函数，如例子中的获取大小`size()`，此外还有查询子串等。

---
title: 六：C++内存模型、管理
date: 2024-04-19 00:00:00 +0800
last_modified_at: 2024-04-22 00:00:00 +0800
categories: [cpp, syntax]
tags: [cpp]
author: author1
---

### 前文

C++的优势是在**运行时**能有效的分配和释放内存，本章节说明C++的内存怎么分配，有哪些相关名词，相关函数。

C++的内存模型在不同系统中不一定是一致的。

### 正文

#### 内存模型

C++程序的内存分为四个部分：
- 代码区：存放函数体的二进制代码，由操作系统进行管理。
- 全局区：存放全局变量、静态变量以及常量区常量。
- 栈（Stack）：在函数内部声明的所有变量都将占用栈内存。
- 堆（Heap）：这是程序中未使用的内存，在程序运行时可用于动态分配内存。

对于不同的区域，编译器定的生命周期是不一样的。

**代码区**存放二进制代码，显然需要程序运行完释放，且这个区域只读。

**全局区**就是之前说的存放全局变量还是上一章节中的`static`等，把`static`关键字和内存联系起来就好理解说`static`不改变访问修饰权限了。

**栈**由编译器自动分配释放（这个意思是说主动分配内存是在堆中进行），存放局部变量等，且符合先进后出原则（这也就是为什么函数能递归），如执行函数，到函数体结束时释放内存。

**堆**由编程人员自己分配，如果不进行释放操作，则程序结束系统释放，使用堆是为了更好的管理内存，如分配数组，往往一次性定义数组大小并不会全部使用完，浪费了内存。这里需要注意内存泄漏。

#### 动态分配内存

首先说明**动态**是什么意思，**动态**的意思是说程序运行时动态加载、释放，相应的，**静态**指编译时就确定的，如全局变量，这个地址编译时就确定了，所以一般不说静态内存管理。

C中用`malloc, calloc, realloc`和`free`，C++中是`new`和`delete`（注意，这两个是操作符），`new`需配合使用`delete`。

注意C++中仍保留了`malloc`，但`new`不只是分配了内存，它还创建了对象。

#### new delete

语法，单个数据：
```
数据类型 *指针变量 = new 数据类型;
delete 指针变量;
// int *p = new int;
// delete p;
```

对于单个数据来说，即对相应的地址分配内存，如在`指针变量`上连续分配`数据类型`的大小（注意这里不需要`sizeof`了），同样对`指针变量`进行释放。

注意，分配如果失败需要检查`p`是否为空：
```
int * foo;
foo = new (nothrow) int [5];
if (foo == nullptr) {
  // error assigning memory. Take measures.
}
```

**这里nullptr是C++11引入的，用于表示空指针，NULL虽然也可以，但实际上NULL被定义为整数0，可能会导致类型错误**。

如上述例子，`nothrow`即告诉编译器分配失败不要抛出异常，其次为如果是空指针的逻辑。

语法，数组：
```
数据类型 *指针变量 = new 数据类型[大小];
delete[] 指针变量;
// int *p = new int[10];
// delete[] 指针变量;
```

同样的，这里连续分配了10个`int`大小的空间，这里也可以用`*p; *(p+1)`来访问元素，删除时则需告知编译器是数组。

**new的优势**：
- `new`操作符能被重载
- 内存不足会抛出异常
- 注意`new`创建后返回的数据类型不再需要类型准换
- 不需要使用`sizeof`了
- 可以初始化对象

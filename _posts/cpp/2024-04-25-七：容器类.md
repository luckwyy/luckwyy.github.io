---
title: 七：STL容器类
date: 2024-04-25 00:00:00 +0800
last_modified_at: 2024-04-25 00:00:00 +0800
categories: [cpp, syntax]
tags: [cpp]
author: author1
---

### 前文

本章节了解C++标准库（Standard Template Library）中常用的容器类的用法。

### 正文

容器类即C++本身开发了一些管理数组、链表等数据结构的类。
要点：
头文件：
**用法：**
创建：
访问：
增加：
修改：
删除：

#### 数组 vector

要点：
- `vector`是基于数组的数据结构
- 可以自动管理内存，不需要手动分配和释放内存。
- 在内存中连续存储
- 这是数组，访问和修改元素时间复杂度小，更换元素顺序即需要参考各时间复杂度的排序算法

头文件：
```
#include <vector>
```

**用法：**

创建：
```
std::vector<int> myVector; // 创建一个存储整数的空 vector
std::vector<int> myVector(5); // 创建一个包含 5 个整数的 vector，每个值都为默认值（0）
std::vector<int> myVector(5, 10); // 创建一个包含 5 个整数的 vector，每个值都为 10
std::vector<int> myVector = {1, 2, 3, 4}; // 初始化一个包含元素的 vector
```

访问：
```
int x = myVector[0]; // 获取第一个元素
int y = myVector.at(1); // 获取第二个元素
// 遍历 这里begin是返回一个迭代器
for (auto it = myVector.begin(); it != myVector.end(); ++it) {
    std::cout << *it << " ";
}
for (int element : myVector) {
    std::cout << element << " ";
}
// 注意直接 << 输出是不行的，因为 << 运算符没有对vector进行重载
// cout << myVector << endl;
```

增加：
```
// 注意，vector双向队列等结构，所以头部插入即移位效率低
myVector.push_back(7); // 将整数 7 添加到 vector 的末尾
```

修改：
```
myVector[0] = 100;
myVector.at(1) = 200;
*(&myVector[0]) = 300;
```

删除：
```
myVector.erase(myVector.begin() + 2); // 删除第三个元素
myVector.clear(); // 清空 vector 所有元素
```

大小：
```
int size = myVector.size(); // 获取 vector 中的元素数量
```

#### 链表 list

要点：
- 链表，在结构中增加删除元素方便（如设置空指针重指向即可）
- 存储空间不需要连续
- 存储时每个元素需要知道前后元素地址（双向链表）
- 链表不是数组，不支持下标访问

头文件：
```
#include <list>
```

**用法：**

创建：
```
list<int> myList; //默认构造空链表
list<int> myList(8, 1); //带参构造，8个val值为1的节点

vector<int> arr = { 1,2,3,4,5,6 };
list<int> myList(arr.begin(), arr.end()); // 通过迭代器构造

list<int> myList2(myList); // 拷贝一个现有的list

const char* str = "str";
list<char> myList(str, str + strlen(str)); // 意味着可以拷贝其他类型，字符串字面量是const char[]
```

访问：
```
//正向遍历
list<char>::iterator it = myList.begin();
while (it != myList.end())
{
	cout << *it;
	it++;
}
//反向遍历
list<char>::reverse_iterator rit = myList.rbegin();
while (rit != myList.rend())
{
	cout << *rit;
	rit++;
}
myList.front() //访问哨兵位数据，开始是头数据，随指针变化
myList.back() //访问链尾数据
```

增加：
```
myList.assign(3, 6); //赋值为3个6
myList.push_front() //头插
myList.pop_front() //头删
myList.push_back() //尾插
myList.pop_back() //尾删
// 中间插入数据需要配合find使用，即告诉编译器在哪个位置插入数据
// 下代码告诉编译器在开始和结尾找值为2的元素并返回其迭代器
auto poss = find(myList.begin(), myList.end(), 2);
myList.insert(poss, 6); //指定位置插入6
myList.insert(poss, 3, 8); //指定位置插入3个8
myList.insert(poss, myList2.begin(), myList2.end()); //指定位置插入一段数据
```

修改：
```
myList.splice(myList需要被拼接位置的迭代器, 准备拼接的数据)
// 注意准备拼接的数据被拼接后，其拼接位置迭代器失效
reverse(); //反转链表
sort(); //默认从小到大排序
// 或利用find修改指定位置元素
```

删除：
```
// 同样的，也要先找到元素
myList.erase(poss); //删除指定位置的值
myList.erase(myList.begin(), myList.end()); //全删
myList.clear(); //全删
// 也有快捷方法
myList.remove(2); //移除元素2
```

大小：
```
cout << l1.size() << endl;
cout << l1.empty() << endl; //判空
cout << l1.max_size() << endl; //判定空间
resize(num); //重新设置空间大小
resize(num, elem); //并以elem元素填充不足
```
#### 栈 stack

要点：
- 底层一般是数组实现
- 符合栈的特点

头文件：
```
#include <stack>
```

**用法：**

创建：
```
stack<int> myStack; // 定义一个储存数据类型为int的stack容器
stack<int> myStack[];
```

访问：
```
top() //返回堆栈顶部的元素
```

增加：
```
push() //向堆栈顶部添加元素
```

修改：
```
```

删除：
```
pop() //弹出堆栈顶部的元素
```

大小：
```
bool isEmpty = myStack.empty(); //判断堆栈是否为空
size() //返回堆栈中元素的个数
```

#### 队列 deque

要点：
- 底层是双向队列结构（double ended queue）
- 底层由指向内存块的指针数组构成而不是链表
- 存储空间连续，结构比vector复杂
- 队列特点：首位增加删除效率高，和数组一样，中间插入要移动位置效率不高
- 创建双端队列对象时会自动分配一块内存，以便可以将对象存储在连续的位置
- 添加开头新元素时，会分配一个新的内存块并连接前一个内存块，再次向前面添加，将被存储在这个新的内存块中，直到完全填满
- 插入末尾时，分配的内存块会保留，直到完全填满；如果满了，分配新内存块并将连接到前一个块的末尾。 添加到双端队列后面的元素现在存储在新的内存块中。

头文件：
```
#include <deque>
```

**用法：**

创建：
```
//deque的定义 
deque<int> myDeque; //定义一个储存数据类型为int的双端队列
deque<int> myDeque[n]; //定义一个储存数据类型为int的双端队列数组
```

访问：
```
// 迭代器遍历
for(auto it=myDeque.begin(); it!=myDeque.end(); it++)
{
	cout << *it << " ";
}
// 下标遍历
for(int i=0; i<myDeque.size(); i++)
{
	cout << myDeque[i] << " ";
}
for(int it : myDeque)
{
	cout << it << " ";
}
myDeque.at(1); // 访问第一个元素
```

增加：
```
push_back() //在队列的尾部插入元素。
emplace_front() //与push_front()的作用一样 
push_front() //在队列的头部插入元素。
emplace_back() //与push_back()的作用一样
insert() //在指定位置插入元素 
```

修改：
```
myDeque[i] = 10;
```

删除：
```
pop_back() //删除队列尾部的元素。
pop_front() //删除队列头部的元素。
erase() //在指定位置删除元素 
clear() //清空队列中的所有元素。
```

大小：
```
empty() //判断队列是否为空。
size() //返回队列中元素的个数。
```
